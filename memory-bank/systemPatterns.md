# Goosuke システムパターン

## システムアーキテクチャ

Goosuke は以下の主要コンポーネントで構成されています：

```
                       ┌────────────────────────────────────┐
                       │            コンテナ                 │
   ┌─────────┐        │  ┌────────┐      ┌──────────────┐  │       ┌─────────────┐
   │ Slack   │◄───────┼──┤ 発火    │◄────┤ 実行レイヤー  │   │      │ Notion      │
   │ Teams   │        │  │ レイヤー│      │ (Goose CLI)  │  │      │ Google Drive│
   │ Email   │────────┼─►│        │─────►│ Extensions   │──┼─────►│ JIRA        │
   └─────────┘        │  └────────┘      └──────────────┘  │      │ その他      │
                      │            ▲          ▲            │      └─────────────┘
                      └────────────┼──────────┼────────────┘
                                   │          │
                          ┌────────┘          └────────┐
                          │                            │
                  ┌───────┴────────┐         ┌─────────┴─────────┐
                  │   認証サービス  │         │ ストレージサービス  │
                  └────────────────┘         └───────────────────┘
```

### 主要コンポーネント

#### 1. 発火レイヤー
発火レイヤーは、システムへの入力点を受け取り、タスクを生成するコンポーネントです。

**主な役割**:
- 「アクション」の受け取り（APIリクエスト、Webhook、Botなど）
- コンテキストの抽出
- タスクの生成
- 認証・認可処理

**技術実装**:
- FastAPI（RESTful API）
- Pydantic（データ検証）
- SQLAlchemy（データベースアクセス）
- JWT（認証）

#### 2. 実行レイヤー
実行レイヤーは、発火レイヤーから受け取ったタスクを実行するコンポーネントです。

**主な役割**:
- タスクの実行
- Goose CLIの呼び出し
- 拡張機能の管理
- 実行結果の処理

**技術実装**:
- Goose CLI
- Python サブプロセス
- 拡張機能システム

#### 3. 認証サービス
認証サービスは、ユーザー認証と認可を担当するコンポーネントです。

**技術実装**:
- JWT（JSON Web Token）
- Passlib（パスワードハッシュ）

#### 4. ストレージサービス
ストレージサービスは、データの永続化を担当するコンポーネントです。

**技術実装**:
- SQLite（小規模用）
- SQLAlchemy（ORM）
- Alembic（マイグレーション）

## 設計パターン

### 1. アクションとタスクのパターン

Goosuke の中核となる概念は「アクション」と「タスク」です：

- **アクション**: システムへの入力点（APIリクエスト、Slack/Discord botのメッセージ、Webhookなど）
- **タスクテンプレート**: ユーザーが望む動作を記述した「プロンプト」と実行タイプを定義したもの
- **タスク実行**: タスクテンプレートと「コンテキスト」を組み合わせた実際の実行インスタンス

このパターンにより、新しいアクションとタスクテンプレートを定義するだけで、様々な作業を自動化できます。

### 2. レイヤードアーキテクチャ

Goosuke は以下のレイヤーで構成されています：

1. **プレゼンテーションレイヤー**: API、Webhook、Botなどのインターフェース
2. **アプリケーションレイヤー**: ビジネスロジック、サービス
3. **ドメインレイヤー**: モデル、エンティティ
4. **インフラストラクチャレイヤー**: データベース、外部サービス連携

### 3. サービスパターン

各機能は独立したサービスとして実装されています：

- **UserService**: ユーザー管理
- **ActionService**: アクション管理
- **TaskService**: タスク管理
- **ExtensionService**: 拡張機能管理
- **DiscordService**: Discord連携
- **SettingService**: 設定管理と秘密情報の処理

### 4. 依存性注入パターン

FastAPIの依存性注入システムを活用して、コンポーネント間の結合度を低減しています。

### 5. 非同期コンテキスト管理パターン

データベース接続などのリソースを非同期コンテキスト管理で効率的に扱います。

```python
@asynccontextmanager
async def _get_db_context():
    async with async_session() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
```

### 6. 秘密情報管理パターン

APIキーやトークンなどの秘密情報を安全に管理するためのパターンを実装しています：

- **秘密情報フラグ**: 設定に`is_secret`フラグを設け、秘密情報かどうかを識別
- **暗号化・復号化**: 秘密情報は保存時に暗号化し、使用時に復号化
- **マスキング**: API応答では秘密情報を「********」でマスク表示
- **拡張機能との連携**: 拡張機能に関連する秘密情報のキーリストを管理

```python
# 秘密情報の暗号化
def encrypt_value(value):
    f = Fernet(_get_encryption_key())
    encrypted = f.encrypt(json.dumps(value).encode())
    return base64.urlsafe_b64encode(encrypted).decode()

# 秘密情報の復号化
def decrypt_value(encrypted_value):
    f = Fernet(_get_encryption_key())
    decrypted = f.decrypt(base64.urlsafe_b64decode(encrypted_value))
    return json.loads(decrypted.decode())
```

## データフロー

### 基本フロー

1. ユーザーがDiscordで鉛筆リアクションを付ける（アクション）
2. Discord Botがリアクションを検出
3. DiscordConfigServiceが設定を取得
4. ActionConfigServiceが関連するアクションを取得
5. メッセージの内容からコンテキストを抽出
6. アクションに関連するタスクテンプレートを取得
7. タスクテンプレートとコンテキストからタスク実行を生成
8. 生成されたタスク実行を実行レイヤーに渡す
9. 実行レイヤーがGoose CLIを使用してタスクを実行
10. 結果をDiscord Botを通じてチャンネルに返送

### 拡張機能設定同期フロー

1. アプリケーション起動時に`ExtensionService`のインスタンスを作成
2. `sync_from_goose`メソッドを呼び出し、Gooseの設定ファイルから拡張機能設定を読み取る
3. 読み取った設定をGoosukeのデータベースに反映する
4. `sync_to_goose`メソッドを呼び出し、Goosukeのデータベースから拡張機能設定を読み取る
5. 読み取った設定をGooseの設定ファイルに反映する

### 秘密情報管理フロー

1. ユーザーが設定を作成または更新する際に`is_secret`フラグを設定
2. `SettingService`が設定を保存する前に、`is_secret`がtrueの場合は値を暗号化
3. データベースには暗号化された値が保存される
4. 設定一覧を取得する際、`is_secret`がtrueの設定は値が「********」でマスク表示される
5. 個別の設定を取得する際、`is_secret`がtrueの設定は値が自動的に復号化される
6. 拡張機能が秘密情報を使用する場合、`secrets`フィールドに秘密情報のキーリストを保持
7. 拡張機能の実行時、必要な秘密情報が自動的に復号化されて提供される